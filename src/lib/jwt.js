import jose from 'jose'
import { createHash, randomBytes } from 'crypto'
import logger from './logger'

const DEFAULT_SIGNATURE_ALGORITHM = 'HS256' //HS512
const DEFAULT_SIGNATURE_ALGORITHMS = ['HS256']
const DEFAULT_ENCRYPTION_ALGORITHM = 'PBES2-HS512+A256KW' // 'ECDH-ES+A256KW'
const DEFAULT_DECRYPTION_ALGORITHMS = ['A128CBC-HS256', DEFAULT_ENCRYPTION_ALGORITHM]
const DEFAULT_ISSUER = 'https://next-auth.js.org'

const encode = async ({
  secret,
  privateKey,
  token = {},
  maxAge,
  signatureAlgorithm = DEFAULT_SIGNATURE_ALGORITHM,
  encryptionAlgorithm = DEFAULT_ENCRYPTION_ALGORITHM,
  issuer = DEFAULT_ISSUER
} = {}) => {
  /*
  token.jit = randomBytes(32).toString('hex')
  token.iat = Math.floor(Date.now() / 1000)
  token.exp = Math.floor(Date.now() / 1000) + maxAge
 */
  const encryption = false

  let keyValue = privateKey
  if (!keyValue) {
    logger.warn('JWT_ENCODE_USING_AUTO_GENERATED_KEY')
    const autoGeneratedKey = createHash('sha256').update(secret).digest('hex')
    if (encryption) {
      keyValue = `{"kty":"oct","kid":"nextauth-auto-generated-encryption-key","alg":"${encryptionAlgorithm}","k":"${autoGeneratedKey}"}`
    } else {
      keyValue = `{"kty":"oct","kid":"nextauth-auto-generated-signing-key","alg":"${signatureAlgorithm}","k":"${autoGeneratedKey}"}`
    }
  }

  const keyInput = JSON.parse(keyValue)
  const key = await jose.JWK.asKey(keyInput)
  const input = jose.util.asBuffer(JSON.stringify(token))
  
  if (encryption) {
    return await jose.JWE.createEncrypt({ format: 'compact', zip: true, alg: encryptionAlgorithm }, key).update(input).final()
  } else {
    //return await jose.JWS.createSign({ format: 'compact', alg: signatureAlgorithm }, key).update(input).final()
    const options = {
      algorithm: signatureAlgorithm,
      jti: randomBytes(32).toString('hex'),
      expiresIn: Math.floor(Date.now() / 1000) + maxAge,
      kid: false,
      issuer,
      header: {
        typ: 'JWT'
      },
    }
    return jose.JWT.sign(token, key, options)
  }
}

const decode = async ({
  secret,
  privateKey,
  publicKey,
  token,
  maxAge,
  signatureAlgorithm = DEFAULT_SIGNATURE_ALGORITHM,
  encryptionAlgorithm = DEFAULT_ENCRYPTION_ALGORITHM,
  signatureAlgorithms = DEFAULT_SIGNATURE_ALGORITHMS,
  decryptionAlgorithms = DEFAULT_DECRYPTION_ALGORITHMS,
} = {}) => {
  if (!token) return null

  const encryption = false

  // Either a Public Key or a Shared Secret (in Private Key) can be used
  let keyValue = publicKey || privateKey
  if (!keyValue) {
    logger.warn('JWT_DECODE_USING_AUTO_GENERATED_KEY')
    const autoGeneratedKey = createHash('sha256').update(secret).digest('hex')
    if (encryption) {
      keyValue = `{"kty":"oct","kid":"nextauth-auto-generated-encryption-key","alg":"${encryptionAlgorithm}","k":"${autoGeneratedKey}"}`
    } else {
      keyValue = `{"kty":"oct","kid":"nextauth-auto-generated-signing-key","alg":"${signatureAlgorithm}","k":"${autoGeneratedKey}"}`
    }
  }

  const publicKeyOrSharedSecret = JSON.parse(keyValue)
  const key = await jose.JWK.asKey(publicKeyOrSharedSecret)

  let payloadResult
  if (encryption) {
    payloadResult = await jose.JWE.createDecrypt(key, { algorithms: decryptionAlgorithms }).decrypt(token)
    const stringFromBuffer = payloadResult.payload.toString('utf8')
    return JSON.parse(stringFromBuffer)
  } else {
  //   payloadResult = await jose.JWS.createVerify(key, { algorithms: signatureAlgorithms }).verify(token)    
  //   const stringFromBuffer = payloadResult.payload.toString('utf8')
  //   return JSON.parse(stringFromBuffer)
    const options = {
      issuer,
      algorithms: DEFAULT_SIGNATURE_ALGORITHMS,
      maxTokenAge: maxAge
    }
    return jose.JWT.verify(token, key, options)
  }

}

const getToken = async ({
  req,
  secret,
  key = secret,
  maxAge,
  encryption,
  secureCookie,
  cookieName
}) => {
  if (!req) throw new Error('Must pass `req` to JWT getToken()')

  // If cookie is not specified, choose what cookie name to use in a secure way
  if (!cookieName) {
    if (typeof secureCookie === 'undefined') {
      // If secureCookie is not specified, assume unprefixed cookie in local dev
      // environments or if an explictly non HTTPS url is specified. Otherwise
      // asssume a secure prefixed cookie should be used.
      secureCookie = !((!process.env.NEXTAUTH_URL || process.env.NEXTAUTH_URL.startsWith('http://')))
    }
    // Use secure prefixed cookie by default. Only use unprefixed cookie name if
    // secureCookie is false or if the site URL is HTTP (and not HTTPS).
    cookieName = (secureCookie) ? '__Secure-next-auth.session-token' : 'next-auth.session-token'
  }

  // Try to get token from cookie
  let token = req.cookies[cookieName]

  // If cookie not provided, look for bearer token in HTTP authorization header
  // This allows clients that pass through tokens in headers rather than as
  // cookies to use this helper function.
  if (!token && req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {
    const urlEncodedToken = req.headers.authorization.split(' ')[1]
    token = decodeURIComponent(urlEncodedToken)
  }

  try {
    return await decode({ secret, key, token, maxAge, encryption })
  } catch (error) {
    return null
  }
}

export default {
  encode,
  decode,
  getToken
}
