import jose from 'jose'
import { createHash } from 'crypto'
import logger from './logger'

// Set default algorithm to use for signing
const DEFAULT_SIGNATURE_ALGORITHM = 'HS512'
const DEFAULT_SIGNATURE_ALGORITHMS = [ DEFAULT_SIGNATURE_ALGORITHM ]

// Set default algorithm to use for encryption
// YOU SHOULD NOT USE PBES2-HS512+A256KW IN PRODUCTION IN THIS WAY
// (i.e. with a shared secret where a token can be trivially re-generated)
// JSON Web Algorithms (JWA) RFC 7518 recommends ECDH-ES+A256KW
const DEFAULT_ENCRYPTION_ALGORITHM = 'PBES2-HS512+A256KW'
const DEFAULT_ENCRYPTION_ALGORITHMS = [ DEFAULT_ENCRYPTION_ALGORITHM ]

// Set default JWT claim properties
const DEFAULT_ISSUER = 'https://next-auth.js.org'

// Generate warning when keys not set, but don't want to flood the logs
let SIGNING_KEY_WARNING = false
let ENCRYPTION_KEY_WARNING = false

const encode = async ({
  token = {},
  maxAge,
  secret,
  encryptionPrivateKey,
  encryptionPublicKey,
  signingPrivateKey,
  signingPublicKey,
  issuer = DEFAULT_ISSUER,
  encryption = true
} = {}) => {

  // Signing Key
  let signingKeyValue = signingPublicKey || signingPrivateKey
  if (!signingKeyValue) {
    if (!SIGNING_KEY_WARNING) {
      logger.warn('JWT_ENCODE_AUTO_GENERATED_SIGNING_KEY')
      SIGNING_KEY_WARNING = true
    }
    const autoGeneratedSigningSecret = createHash('sha256').update(secret).digest('hex')
    signingKeyValue = `{"kty":"oct","kid":"nextauth-auto-generated-signing-key","alg":"${DEFAULT_SIGNATURE_ALGORITHM}","k":"${autoGeneratedSigningSecret}"}`
  }
  const signingKeyInput = JSON.parse(signingKeyValue)
  const signingKey = await jose.JWK.asKey(signingKeyInput)

  const signedToken = jose.JWT.sign(token, signingKey, {
    expiresIn: `${maxAge}s`,
    kid: false,
    issuer
  })

  if (encryption) {
    // Encryption Key
    let encryptionKeyValue = encryptionPublicKey || encryptionPrivateKey
    if (!encryptionKeyValue) {
      if (!ENCRYPTION_KEY_WARNING) {
        logger.warn('JWT_ENCODE_AUTO_GENERATED_ENCRYPTION_KEY')
        ENCRYPTION_KEY_WARNING = true
      }
      const autoGeneratedEncryptionSecret = createHash('sha256').update(secret).digest('hex')
      encryptionKeyValue = `{"kty":"oct","kid":"nextauth-auto-generated-encryption-key","alg":"${DEFAULT_ENCRYPTION_ALGORITHM}","k":"${autoGeneratedEncryptionSecret}"}`
    }
    const encryptionKeyInput = JSON.parse(encryptionKeyValue)
    const encryptionKey = await jose.JWK.asKey(encryptionKeyInput)
    
    // Encrypt
    const tokenToEncrypt = signedToken
    return jose.JWE.encrypt(tokenToEncrypt, encryptionKey)
  } else {
    return signedToken
  }
}

const decode = async ({
  token,
  maxAge,
  issuer = DEFAULT_ISSUER,
  secret,
  encryptionPrivateKey,
  signingPrivateKey,
  signatureAlgorithms = DEFAULT_SIGNATURE_ALGORITHMS,
  encryptionAlgorithms = DEFAULT_ENCRYPTION_ALGORITHMS,
  encryption = true
} = {}) => {
  if (!token) return null

  let tokenToVerify = token

  if (encryption) {
    // Decryption Key
    let encryptionKeyValue = encryptionPrivateKey
    if (!encryptionKeyValue) {
      const autoGeneratedEncryptionSecret = createHash('sha256').update(secret).digest('hex')
      encryptionKeyValue = `{"kty":"oct","kid":"nextauth-auto-generated-encryption-key","alg":"${DEFAULT_ENCRYPTION_ALGORITHM}","k":"${autoGeneratedEncryptionSecret}"}`
      encryptionAlgorithms = DEFAULT_ENCRYPTION_ALGORITHMS
    }
    const encryptionKeyInput = JSON.parse(encryptionKeyValue)
    const encryptionKey = await jose.JWK.asKey(encryptionKeyInput)
    const tokenToDecrypt = tokenToVerify
    // Decrypt
    tokenToVerify = jose.JWE.decrypt(tokenToDecrypt, encryptionKey, { algorithms: encryptionAlgorithms })
    tokenToVerify = tokenToVerify.toString('utf8')
  }

  // Signing Key
  let signingKeyValue = signingPrivateKey
  if (!signingKeyValue) {
    const autoGeneratedSigningSecret = createHash('sha256').update(secret).digest('hex')
    signingKeyValue = `{"kty":"oct","kid":"nextauth-auto-generated-signing-key","alg":"${DEFAULT_SIGNATURE_ALGORITHM}","k":"${autoGeneratedSigningSecret}"}`
  }
  const signingKeyInput = JSON.parse(signingKeyValue)
  const signingKey = await jose.JWK.asKey(signingKeyInput)
  
  return jose.JWT.verify(tokenToVerify, signingKey, {
    issuer,
    algorithms: signatureAlgorithms,
    maxTokenAge: `${maxAge}s`
  })
}

const getToken = async ({
  // Specific to getToken()
  req,
  secureCookie,
  cookieName,
  // Passed through to decode()
  maxAge = 30 * 24 * 60 * 60,
  issuer = DEFAULT_ISSUER,
  secret,
  encryptionPrivateKey,
  signingPrivateKey,
  signatureAlgorithms = DEFAULT_SIGNATURE_ALGORITHMS,
  encryptionAlgorithms = DEFAULT_ENCRYPTION_ALGORITHMS,
  encryption = true,
} = {}) => {
  if (!req) throw new Error('Must pass `req` to JWT getToken()')

  // If cookie is not specified, choose what cookie name to use in a secure way
  if (!cookieName) {
    if (typeof secureCookie === 'undefined') {
      // If secureCookie is not specified, assume unprefixed cookie in local dev
      // environments or if an explictly non HTTPS url is specified. Otherwise
      // asssume a secure prefixed cookie should be used.
      secureCookie = !((!process.env.NEXTAUTH_URL || process.env.NEXTAUTH_URL.startsWith('http://')))
    }
    // Use secure prefixed cookie by default. Only use unprefixed cookie name if
    // secureCookie is false or if the site URL is HTTP (and not HTTPS).
    cookieName = (secureCookie) ? '__Secure-next-auth.session-token' : 'next-auth.session-token'
  }

  // Try to get token from cookie
  let token = req.cookies[cookieName]

  // If cookie not provided, look for bearer token in HTTP authorization header
  // This allows clients that pass through tokens in headers rather than as
  // cookies to use this helper function.
  if (!token && req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {
    const urlEncodedToken = req.headers.authorization.split(' ')[1]
    token = decodeURIComponent(urlEncodedToken)
  }

  try {
    return await decode({
      token,
      maxAge,
      encryption,
      issuer,
      secret,
      encryptionPrivateKey,
      signingPrivateKey,
      signatureAlgorithms,
      encryptionAlgorithms,
      encryption
    })
  } catch (error) {
    return null
  }
}

export default {
  encode,
  decode,
  getToken
}
